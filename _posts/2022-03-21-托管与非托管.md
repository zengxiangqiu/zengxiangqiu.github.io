---
title: "托管与非托管"
date:  2022-03-21 14:58:20 +0800
categories: [其他]
tags: [托管]
---

## 堆栈 VS 托管堆

**堆栈**，由编译器向系统申请，从高地址到低地址分配，LIFO（后入先出）的数据结构，每个线程通常分配**2M**的栈空间

而32 位计算机上的每个**进程**都具有 **2 GB**的用户模式**虚拟地址空间**（VMM）,所以理论上该进程可以拥有1024个线程

声明int类型变量，push入栈，对应的汇编的指令   push ax

运行操作指令（运算）如何访问：栈顶地址+偏移量，也就是说机器码到汇编的时候加载入RAM（随机存储器）时**指令集**包含了指令要访问的地址和操作符

退出函数或线程时将这一段栈内的数据pop出，指令也回到主函数的原先的位置，这样栈被释放的空间将被其他的函数或线程继续使用，这些都将写在指令集里

堆栈的访问速度也因指针的上下移动而比堆（二叉树）的寻址要快。

**托管堆**，托管堆与数据结构的堆不同，它是一段连续的内存，而堆是经过排序的二叉树

栈中有堆对应的地址，出栈后，堆内的数据将由GC释放,GC是CLR的一部分，GC调用**汇编指令delete**释放内存

.net程序将被编译为MSIL（微软中间语言）存放在PE文件中（.exe或dll），也称为程序集，是编译的一个逻辑单元，包括了程序集清单、图片资源等，加载时由CLR调用JIT转为IL（中间语言，也叫本机代码，汇编），再由cpu执行汇编指令，当IL加载入RAM时会向系统申请堆栈和连续的托管堆内存,每个线程都有它的堆栈,**堆始终在所有线程之间共享**，即使程序意外退出CLR的垃圾回收算法也能回收

## 延伸

**非托管类型**,int等内置类型，枚举类型，指针类型，struct类型,不由GC管理，系统分配和释放

**托管类型**，引用类型，新建实例时，存放在托管堆内，GC管理

**托管资源**，由GC管理释放的内存

**非托管资源**

GC可以跟踪封装非托管资源的对象的生存期，但它不了解具体如何清理这些资源。

涉及大量非托管代码：所有文件句柄、数据库连接、网络套接字……所有这些都是普通的非托管 Win32 代码

每次打开文件 ( FileStream) 时，您基本上都在调用（当然是在幕后）CreateFile非托管 Win32 函数


## 参考

[什么是 CLR ？](https://zhuanlan.zhihu.com/p/68158037)

[托管执行过程](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process)
