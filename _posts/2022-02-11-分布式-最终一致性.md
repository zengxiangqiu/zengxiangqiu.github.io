---
title: "分布式 最终一致性"
date:  2022-02-11 10:53:04 +0800
categories: [DevOps]
tags: [一致性]
---

> 我们以前谈到过 CAP，知道如果牺牲一定的一致性就可以保证分区容错性和可用性

# 数据库事务可靠原则ACID

[What does ACID mean in Database Systems?][1]


[ACID vs. BASE: How is Eventual Consistency Similar to Strong Consistency?][4]

> In contrast to SQL’s ACID guarantees, NoSQL databases provide so-called BASE guarantees.

DBMS以ACID原则设计事务，而Redis利用主从异步的方式保证数据最终一致性

> Redis uses a master-slave topology for how to handle eventual consistency, relying on replication from the master node to the slave nodes.


## 原子性

all-or-nothing  成功或者没有发生

## 一致性

数据一致，指没有违反数据库定，包括triggers，cascades,rules,constraints等

## 隔离性

并发中事务之间独立

## 持久性

发生了就应被记录下来


# 分布式事务XA扩展架构协议

[XA Transactions (2 Phase Commit): A Simple Guide][5]

大致分为事务管理器和本地资源管理器

# Two-Phase Commit

2PC是强一致、中心化的原子提交协议

分为准备prepare和commit阶段
  1. vote 准备/投票阶段 由协调者发出命令到每一个参与者，参与者响应ack已执行本地事务，**资源预留**，未提交（vote request），超时再认为投反对
  2. commit 提交阶段 协调者决策，所有参与者Yes，再通知参与者commit事务，如收到任一反对，则由通知其他参与者回滚

优点：

强一致性，因为一阶段预留了资源，所有只要节点或者网络最终恢复正常，协议就能保证二阶段执行成功；

业界标准支持，二阶段协议在业界有标准规范——XA 规范，许多数据库和框架都有针对XA规范的分布式事务实现。

缺点：

在提交请求阶段，需要预留资源，在资源预留期间，其他人不能操作（比如，XA 在第一阶段会将相关**资源锁定**） ，会造成分布式系统**吞吐量大幅下降**；

容错能力较差，比如在节点宕机或者超时的情况下，无法确定流程的状态，只能不断重试，同时这也会导致事务在**访问共享资源时发生冲突和死锁的概率增高**，随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平伸缩的"枷锁"；

# Three-Phase Commit

3PC
1. 询问阶段（CanCommit）
2. **准备阶段（PreCommit）** 锁定资源
3. 提交阶段（DoCommit）


当参与者响应ACK后，即使在指定时间内没收到doCommit指令，也会进行事务的最终提交；一旦进入提交阶段，即使因为网络原因导致参与者无法收到协调者的doCommit或Abort请求，超时时间一过，参与者也会自动完成事务的提交。

优点：

增加了一个询问阶段，询问阶段可以确保尽早的发现无法执行操作的参与者节点，提升效率；

在准备阶段成功以后，协调者和参与者执行的任务中都增加了超时，一旦超时，参与者都会继续提交事务(释放资源)，默认为成功，降低了阻塞范围。

缺点：

如果准备阶段执行事务后，某些参与者反馈执行事务失败，但是由于出现网络分区，导致这些参与者无法收到协调者的中止请求，那么由于超时机制，这些参与者仍会提交事务，导致出现不一致；

性能瓶颈，不适合高并发场景。

所以无论是 2PC 还是 3PC，当出现网络分区且不能及时恢复时， 都不能保证分布式系统中的数据 100% 一致。

增加系统负载和响应延迟。也正是因为这些问题，**三阶段提交协议很少被使用**。

# TCC Try-Confirm-Cancel

两阶段提交（2PC）和三阶段提交（3PC）并不适用于并发量大的业务场景。TCC事务机制相比于2PC、3PC，**不会锁定整个资源**，而是通过引入补偿机制，将资源转换为业务逻辑形式，锁的粒度变小。

TCC仍然是一个两阶段提交协议。但是，在执行出现问题的时候，有一定的自我修复能力，如果任何一个事务参与者出现了问题，协调者可以通过执行逆操作来取消之前的操作，达到最终的一致状态（比如冲正交易、查询交易）

又称补偿事务，针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）

目前相对比较成熟的是阿里开源的分布式事务框架seata

Confirm 和 Cancel 应幂等

Try 资源预留，比如**库存冻结**,而不是直接扣减库存（可以理解为真正意义上的锁定资源）

Confirm 事务提交 扣减库存

**Cancel** 补偿 **释放之前的冻结库存** ，也可以是业务层面的操作，跨库操作

优点
跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些，当然性能也可以得到提升。

缺点
TCC模型对业务的侵入性太强，事务回滚实际上就是自己写业务代码来进行回滚和补偿，改造的难度大。一般来说支付、交易等核心业务场景，可能会用TCC来严格保证分布式事务的一致性，要么全部成功，要么全部自动回滚。这些业务场景都是整个公司的核心业务有，比如银行核心主机的账务系统，不容半点差池。

但是，在一般的业务场景下，尽量别没事就用TCC作为分布式事务的解决方案，因为自己手写回滚/补偿逻辑，会造成业务代码臃肿且很难维护。



引用[分布式理论之分布式事务：TCC](https://mp.weixin.qq.com/s?__biz=MzIwMjU4MzU4MA==&mid=2247484760&idx=1&sn=71b25418a2fc110539eae4fb7f0bbdeb&chksm=96dd3e2ba1aab73d16d34d03ca49c2f1aaf57f58c78cb4c7234ce8c18cd1c899c2ac9659084e&cur_album_id=1343082386795626497&scene=189#wechat_redirect)

> TCC模型对业务的侵入性太强，事务回滚实际上就是自己写业务代码来进行回滚和补偿，改造的难度大。一般来说支付、交易等核心业务场景，可能会用TCC来严格保证分布式事务的一致性，要么全部成功，要么全部自动回滚。这些业务场景都是整个公司的核心业务有，比如银行核心主机的账务系统，不容半点差池。

> 但是，在一般的业务场景下，尽量别没事就用TCC作为分布式事务的解决方案，因为自己手写回滚/补偿逻辑，会造成业务代码臃肿且很难维护。

# 本地消息表

T2PC、3PC 、TCC 无法保证本地事务和投递消息MQ all-or-nothing，可能会导致数据不一致，所以引入消息表

常见问题：
1. 上游服务 1.执行本地事务 2.投递消息 有可能1完成，2因为网络返回失败（但实际已发送MQ），这样1回滚，2已发送，影响下游。
2. 1.投递 2.执行本地，投递完成，2失败，同样影响下游

引入消息表

1.执行本地事务， 2.更新消息表 3.投递消息

将12放在同一个事务执行，新建**定时任务**扫描消息表，发现已执行未投递的则投递，并更新消息状态未已发送

常见问题：
1. 定时任务投递投递后宕机，恢复后重复投递，这种情况要求下游业务支持幂等操作
2. 1. 维护消息表成本 2. 消息处理和业务耦合 3. 消息处理本地数据库（持久化）读写对高并发不友好 4. 定时扫描增加系统间的延迟


所以引入可靠消息

# **可靠消息最终一致性**

[分布式事务中的最终一致性](https://cdmana.com/2022/01/202201300559396195.html)非常通俗易懂，以案例解析本地消息表的实践。

在本地消息的基础上新增了可靠消息服务、本地事务表和消息表（待确认，已发送，取消，完全的）

上游服务在prepare后会向可靠消息服务发送 待确认和回调接口（询问上游服务是否发送待确认的消息和补偿接口），上游服务将本地事务完成后发送确认信息给消息服务，消息服务在同一个事务中发送消息到MQ并将待确认修改已发送，下游订阅事件，处理完成后ack答复MQ，同时消息服务订阅ack答复事件，收到后在同一个事务中更新消息状态为已完成/取消，消息服务通过上游的回调接口通知上游完成或补偿。


1.上游发送准备消息和回调接口到消息服务 2.上游执行本地事务 3.上游发送确认发送消息到消息服务 4.消息服务消息发送到MQ 5.MQ等待下游消费者消费

常见问题
1. 23应放在同一个事务中，保证all-or-nothing
2. 消息服务持久化， 上游在3之前宕机，消息服务会通过回调接口查询上游是否可以投递确认消息到MQ，上游决定是否commit或rollback
3. 消息服务如出现故障，将重复投递消息到MQ，所以下游应支持幂等，同样上游的补偿也应支持幂等（判重表）

可靠消息最终一致性方案，一般适用于异步的服务调用，比如支付成功后，调用积分服务进行积分累加、调用库存服务进行发货等等。总结一下，可靠消息最终一致性方案其实最基本的思想就两点：

通过引入消息中间件，保证生产者对消息的100%可靠投递；

通过引入Zookeeper，保证消费者能够对未成功消费的消息进行重新消费（消费者要保证自身接口的幂等性）。

优缺点
可靠消息最终一致性方案是目前业务主流的分布式事务落地方案，其优缺点主要如下：

优点： 消息数据独立存储，降低业务系统与消息系统间的耦合。

缺点： 一次消息发送需要两次请求，业务服务需要提供消息状态查询的回调接口。

一般来讲，99%的分布式接口调用不需要做分布式事务，通过监控（邮件、短信告警）、记录日志，就可以事后快速定位问题，然后就是排查、出解决方案、修复数据。

因为用分布式事务一定是有成本的，而且这个成本会比较高，特别是对于一些中小型公司。同时，引入分布式事务后，代码复杂度、开发周期会大幅上升，系统性能和吞吐量会大幅下跌，这就导致系统更加更加脆弱，更容易出bug。当然，如果有资源能够持续投入，分布式事务做好了的话，好处就是可以100%保证数据一致性不会出错。

1. Saga模式

相比TCC，少了confirm

try 直接提交操作，

   1. 服务之间的Saga模式实现

      1. 编排式

        开发编排器类，发起后通过MQ， 统一管理各个服务的事务和补偿

      2. 协同式

        各个服务通过MQ互相订阅事件






[分布式系统理论基础 - 一致性、2PC和3PC](https://zhuanlan.zhihu.com/p/21994882)




# 分布式系统CAP定理

[CAP 定理中的“CAP”解释][2]

分布式系统理论上只能满足任意两个特性，而牺牲另一个。

# 一致性

不同节点（集群服务）获取数据是一致的

# 可用性

即使某个节点关闭，对所有请求都有响应，不会抛出异常或超时

# 分区容忍性

指系统能够容忍节点之间的网络通信的故障

节点之间连接丢失，集群依然能正常工作，虽然不能保证数据的正确。

因为网络原因，分区成为必不可少的因素，一般选择CP，或AP定理去设计。

# 分布式系统BASE理论

Basically Available/Soft State/Eventually consistent

对AP定理的实际总结，**强调可用性**

# 部分可用 Basically Available

当系统发生错误时，为保证核心功能可用，可以牺牲一些其他功能，可以通过下面的方式实现

## 流削峰
1. 分时间段打包请求
2. MQ 削峰填谷

## 延迟响应
先响应"正在处理中...",再notify通知user

## 服务降级
请求高保真图片变为低分辨率图片

## 过载保护/熔断
熔断后直接拒绝接下来的请求

# 软状态 Soft State

返回中间值，而不是最终值，中间值不是随便的value，只是不是最终的。

# 最终一致性 Eventually consistent

当某一节点出现错误，同步节点的数据将被缓存，在节点恢复后重新提交

# 数据一致性模型
1. 强一致性
2. 弱一致性，有不一致窗口期
3. 最终一致性，没有确定的窗口期，但最终会一致













[1]:https://database.guide/what-is-acid-in-databases/
[2]:https://www.ibm.com/cloud/learn/cap-theorem
[3]:https://developpaper.com/cap-and-base-theory-in-distributed-system/#:~:text=Base%20theory%20can%20be%20understood%20as%20cap%20theory,functions%20to%20ensure%20the%20availability%20of%20core%20functions.
[4]:https://www.scylladb.com/glossary/eventual-consistency/
[图解分布式之：最终一致性，一致只会迟到，但绝不缺席](https://www.cnblogs.com/siyuanwai/p/14302444.html)
[5]:https://dzone.com/articles/xa-transactions-2-phase-commit


# 事务隔离

## 现象

多了，少了，变了

1. Dirty Read 脏读

   AB事务，同一查询，A事务查询到B事务提交或未提交的更改，数据集变了

2. Non Repeatable read 不可重复读

   AB事务，同一查询，A事务查询不到B事务删除的数据，数据集少了

3. Phantom Read 幻读

   AB事务，同一查询，A事务读到B事务提交或未提交的数据，数据集多了

## 数据库隔离

基于上面三种现象，SQL定义了以下4种隔离级别

1. Read Uncommitted

   读未提交

2. Read Committed

   读已提交,它通过指定语句不能读取已由其他事务修改但尚未提交的数据值来防止脏读。

3. Repeatable Read

   可重复读,任何其他事务都不能修改或删除已由当前事务读取的数据。 由于读取数据上的共享锁一直保持到事务结束

4. Serializable

   序列化, 它包含 REPEATABLE READ 并添加了限制，即在事务完成之前，其他事务不能将新行插入到事务已读取的范围中

   ![现象和隔离级别](https://media.geeksforgeeks.org/wp-content/cdn-uploads/transactnLevel.png)

5. snapshot

   快照隔离，利用tempdb和row version行版本复制（行副本，带事务序列号TNS）

   快照事务始终使用**乐观并发**控制，这会保留阻止其他事务更新行的任何锁。 如果快照事务尝试提交对事务开始后更改的行的更新，则将回滚该事务，并引发错误。

   事务将看到事务开始时存在的所有数据，而不会对基础表执行或设置任何锁。 在存在争用的情况下，这可能导致性能改进

SQL Server default Isolation level **Read Committed**


## 交付保证

[幂等性](https://cap.dotnetcore.xyz/user-guide/zh/cap/idempotence/)

`SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;` 手动修改隔离级别

https://docs.microsoft.com/zh-cn/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server


![高可用](https://pic1.zhimg.com/80/v2-19ca214bad02da99ac605e7ec453b650_720w.jpg)
